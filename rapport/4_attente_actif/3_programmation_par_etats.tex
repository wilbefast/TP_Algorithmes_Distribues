\subsubsection{Exécution pseudo-parallèle}

Si nos machine peuvent tourner \og simultanément \fg{} plus de programmes qu'ils ont de processeurs c'est en itérant très rapidement à travers l'ensemble des processus \footnote {\og Timeslicing \fg{}}. 

Nous pouvions ainsi nous limiter à un seul fil d'exécution par site qui tournera en boucle en passant à travers toutes les taches que le site devrait accomplir, à priori, en parallèle :

\begin{algorithm}[H]
  \caption{$Site::Boucle()$}
  \Donnees
  {\\
    this \textit{// le site courant}\\
  }
  \Deb
  {
  	this.continuer $\leftarrow \top$ \;
  	\Tq{ this.continuer }
	 {
	 	this.lire\_messages() \;
	 	this.lire\_console() \;
	 	\dots
	 }
  }	
\end{algorithm}

L'important ici est d'assurer qu'aucun de ces sous-routines ne soit bloquant. C'est le cas pour lire des datagrammes \texttt{UDP}\footnote{UDP : User-datagram protocole }, et nous pouvions récupérer des appuies clavier avec \texttt{SDL} ou \texttt{kbhit}\footnote{fonction ubiquité mais non-standard : ni POSIX, ni ANSI} de manière non-bloquante.

\subsubsection{Mémoire de l'état courant}
Le vraie problème et le désavantage de cette manière de faire est que nous perdons en bouclant constamment la possibilité d'attendre à un endroit précis dans l'algorithme. 